### 对于Linux中使用`./`执行程序的一些误解


> 开始学习使用linux的时候，一定会碰到想要执行文件，却不知道要怎么办的时候。
这时，我们都会上网去搜索相关的资料。一般网上的回答是，使用 `./ + 文件名` 执行相关的可执行文件，当时也没深究。
> 不过，后来有一次自己想写脚本，却发现文件执行一直报错。大概内容入下：
>> 我需要在脚本中执行`/home/user/hello`文件，根据以前的理解，我在脚步中输入 `./home/user/hello` ，却发现无法执行，但却不知道为啥，后来我将其直接写为 `/home/user/hello` ，却发现可以成功运行。对此，一直很疑惑。
> 在学习《深入理解计算机系统》的过程中，我才发现我对shell外壳命令解释方式理解有误，导致无法正确的理解linux中执行文件的命令。
> 实际上，linux上每个命令都是一个文件。在shell外壳中，shell将输入的数据作为需要执行的文件的文件名（不考虑参数的情况下），而在shell中，`./hello` 就表示的是当前文件下的 `hello`文件的文件名，同样，其文件名也可以表示为 `/home/user/hello` ，即使用 `/home/user/hello` 命令同样也可以执行该命令。
> 这里，就有个关于文件名的坑。按照我们的理解，`/home/user/hello` 的文件名应该是 `hello` ， `/home/user/` 只是其所处的文件夹。但对于shell外壳来说，为了全局定位存储空间中的文件，使用的是 `路径 + 文件名` 来做为执行文件的文件名（当然，你也可以将其理解为shell读取的是其 `路径 + 文件名` ，而不是文件名）。
> 你一定会疑惑为什么shell命令是直接输入其名字来执行命令，比如`ls`命令。其实，shell中还有一种方式来定位文件，那就是通过全局变量 `$PATH`。
> 比如需要执行 `ls` 命令，即 ls 文件时，shell可以直接判断其一定不是 `路径 + 文件名 ` 的格式。于是shell会在 `$PATH`中的路径中搜索文件名为 `ls` 的文件，并执行。
>> 如下为针对该问题进行实验
>> * 首先在文件夹`/home/user/`下有可执行文件`hello`
>> * 使用 `export $PATH=/home/user/` 命令，覆盖默认的全局变量的值
>> * 在shell中输入命令 `hello` 发现可以成功执行
>> * 在shell中输入命令 `ls` 发现显示命令不存在


